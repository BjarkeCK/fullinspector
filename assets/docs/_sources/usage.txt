.. highlight:: csharp

Usage
=====

Working Guide
-------------
The following list is what you need to keep in mind to ensure that your objects serialize correctly and are fully inspectable using Full Inspector.

- Derive from ``BaseBehavior``, not ``MonoBehaviour``
- If you override ``Awake``, immediately call ``base.Awake()``

Let's say your using Json.NET. If a type would normally require a ``[Serializable]`` attribute, then it requires Json.NET attributes. Otherwise, you don't have to do anything. You'll see exactly what this means in the examples below.

.. IMPORTANT::
    If you have custom save-game logic, make sure that you run ``FullInspectorSaveManager.SaveAll()`` before your save logic; it will ensure that every ``BaseBehavior`` instance is ready to go through Unity serialization. Saves can be detected automatically in the editor but not in a published build.

    If you're working with an object in the editor and are modifying it without using the inspector, make sure to restore the serialized data by calling ``RestoreState()``. After you're done modifying it, call ``SaveState()``.

.. IMPORTANT::
    One potential gotcha with serialization: each ``BaseBehavior`` is serialized independently. If you have a class instance that is shared across multiple ``BaseBehaviors``, it will be deserialized into separate instances. You can ensure that it deserializes into one instance by deriving from a ``UnityEngine.Object`` child class, such as ``BaseScriptableObject``.

Examples
--------

Here's an example of how to use Full Inspector with Json.NET:

.. code:: c#

    [JsonObject(MemberSerialization.OptIn)]
    public struct Struct {
        [JsonProperty]
        public GameObject SpawnObject;

        [JsonProperty]
        public Dictionary<string, string> StrStrDict;
    }

    public class JsonNetStructDemoBehavior : BaseBehavior<JsonNetSerializer> {
        public Struct PublicValue;

        [SerializeField]
        [ShowInInspector]
        private Struct _hidden;
    }

.. image:: static/usage_jsonnet.png

-------------------------

Or perhaps you prefer protobuf-net?

.. code:: c#

    [ProtoContract]
    [ProtoInclude(1, typeof(Implementation1))]
    [ProtoInclude(2, typeof(Implementation2))]
    public interface IInterface {
    }

    [ProtoContract]
    public class Implementation1 : IInterface {
        [ProtoMember(1)]
        public int A;
    }

    [ProtoContract]
    public class Implementation2 : IInterface {
        [ProtoMember(1)]
        public bool B;

        [ProtoMember(2)]
        public Transform Location;
    }

    public class InterfaceDemoBehavior : BaseBehavior<ProtoBufNetSerializer> {
        public IInterface MyInterface;
    }

.. image:: static/usage_protobufnet.png

-------------------------

Or maybe even BinaryFormatter (beta)?

.. code:: c#

    [Serializable]
    public struct Struct<TValue> {
        public Dictionary<string, TValue> MyDict;
        public TValue MissingValue;
    }

    public class BinaryFormatterStructDemoBehavior : BaseBehavior<BinaryFormatterSerializer> {
        public Struct<Transform> SomeStruct;

        public enum Enum {
            ValueA, ValueB, ValueC
        }
        public Dictionary<Enum, string> EnumStringDict;
    }

.. image:: static/usage_binaryformatter.png

-------------------------

Full Inspector also includes experimental support for EasySave2. If none of these four serializers is your favorite, then it's extremely easy to add support for a new one.

.. IMPORTANT::
    There are many samples inside of *"FullInspector2/Samples"*.

    The full source code has been provided and it is highly commented, so please feel free to peruse it as well to understand how Full Inspector works internally.
