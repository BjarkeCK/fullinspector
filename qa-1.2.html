<!doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Full Inspector | Q/A (1.2)</title>
    <link rel="stylesheet" href="css/foundation.css" />
    <script src="js/vendor/modernizr.js"></script>
    <link href="css/rainbow/github.css" rel="stylesheet" type="text/css">

</head>
<body>
    <!--
    <div class="row">
      <div class="large-12 columns">
        <h1>Full Inspector</h1>
        <h4>Unity Inspector support for all .NET types</h4>
      </div>
    </div>
    -->

    <div class="row">
        <div class="large-12 columns">
            <div class="panel">
                <h3>Full Inspector QA <small>or go back to the <a href="index.html">homepage</a></small></h3>
            </div>

            <dl class="accordion" data-accordion>
                <dd>
                    <a href="#panel1">I cannot derive from <code>BaseBehavior</code> or <code>BaseScriptableBehavior</code></a>
                    <div id="panel1" class="content">
                        <p>Full Inspector has been designed to handle this scenario, but it'll require a little bit of boilerplate code. Below is the boilerplate code that you need to enable serialization.</p>

                        <p>Funnily enough, if you look into the actual code behind <code>BaseBehavior</code> and <code>BaseScriptableObject</code>, you'll find it to be almost identical to the code below (they hide some of the methods behind an explicit interface, however).</p>

                        <pre><code>/// &lt;summary&gt;
/// This is your base type that extends some other type. It contains boilerplate code to get
/// serialization working correctly.
/// &lt;/summary&gt;
/// &lt;typeparam name="TSerializer"&gt;The type of serializer that will be used.&lt;/typeparam&gt;
public class CustomBaseType&lt;TSerializer&gt; : MonoBehaviour, ISerializedObject
    where TSerializer : BaseSerializer {
    /// &lt;summary&gt;
    /// Ensures that the object has been restored. This is *vitally* important. If you derive from
    /// MonoBehaviour, then this should be Awake. If you derive from ScriptableObject, then this
    /// should be OnEnable.
    /// &lt;/summary&gt;
    protected virtual void Awake() {
        RestoreState();
    }
    /// &lt;summary&gt;
    /// Restore the previously saved state.
    /// &lt;/summary&gt;
    public void RestoreState() {
        SerializationHelpers.RestoreState&lt;TSerializer&gt;(this);
    }
    /// &lt;summary&gt;
    /// Save the current state.
    /// &lt;/summary&gt;
    public void SaveState() {
        SerializationHelpers.SaveState&lt;TSerializer&gt;(this);
    }
    /// &lt;summary&gt;
    /// Has the object been restored? This defaults to false after a Unity serialization cycle,
    /// meaning that the object will need to be restored.
    /// &lt;/summary&gt;
    [NonSerialized]
    public bool Restored {
        get;
        set;
    }
    /// &lt;summary&gt;
    /// This contains the actual serialized state of the object that will be used to restore it.
    /// &lt;/summary&gt;
    [SerializeField]
    private string _serializedState;
    public string SerializedState {
        get {
            return _serializedState;
        }
        set {
            _serializedState = value;
        }
    }
    /// &lt;summary&gt;
    /// This list contains the object references that were encountered during serialization.
    /// &lt;/summary&gt;
    [SerializeField]
    private List&lt;UnityEngine.Object&gt; _serializedObjectReferences;
    public List&lt;UnityEngine.Object&gt; SerializedObjectReferences {
        get { return _serializedObjectReferences; }
    }
}</code></pre>

                        <p>You're also going to want to create an editor for <code>CustomBaseType&lt;TSerializer&gt;</code>. To do this, we need to also perform some generic type erasure. Just introduce a type <code>CustomBaseTypeErased : MonoBehavior, ISerializedObject</code> that <code>CustomBaseType&lt;TSerializer&gt;</code> derives from. Then, we can write an editor for <code>CustomBaseTypeErased</code></p>

                        <pre><code>[CustomEditor(typeof(CustomBaseTypeErased), true)]
public class CustomBaseTypeErasedEditor : FullInspectorCommonSerializedObjectEditor { }</code></pre>
                        <p>This <code>CustomBaseTypeErasedEditor</code> will be used for <code>CustomBaseType&lt;TSerializer&gt;</code>. <code>FullInspectorCommonSerializedObjectEditor</code> provides the inspector editing experience for you.</p>
                    </div>
                </dd>
                <dd>
                    <a href="#panel2">Does Full Inspector impact runtime performance?</a>
                    <div id="panel2" class="content">
                        <p>The only impact that Full Inspector has is a call to <code>Awake</code> for every object that requires special serialization support. The <code>Awake</code> call merely deserializes the object.</p>

                        <p>Full Inspector imposes no runtime impacts (such as a call to <code>Update</code>); in fact, your code will likely run faster will Full Inspector due to less GC pressure because you can now extensively use structs.</p>
                    </div>
                </dd>
            </dl>
        </div>
    </div>


    <script src="js/vendor/jquery.js"></script>
    <script src="js/foundation.min.js"></script>
    <script src="js/vendor/rainbow.min.js"></script>
    <script>
        $(document).foundation();
        $('#myid').foundation('section', { deep_linking: true, multi_expand: true, one_up: false });
    </script>
</body>
</html>
